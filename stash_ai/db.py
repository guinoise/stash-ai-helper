from utils.custom_logging import get_logger
logger= get_logger("stash_ai.db")
import gradio as gr
from typing import Union
from sqlalchemy.orm import Session
from sqlalchemy import create_engine, Engine, select
from stash_ai.config import config
import pathlib
import shutil
from time import sleep
import pyAesCrypt
from datetime import datetime
import tempfile
import tarfile
from stash_ai.model import ImgFile
import os
#logging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)

engine: Engine= None
lock_db= False

def init_engine():
    global engine
    database_file= config.base_dir.joinpath('stash-ai.sqlite3')
    # if not gr.NO_RELOAD and engine is not None:
    #     logger.warning("Closing database on reload")
    #     close_db()
    if lock_db:
        raise ValueError('Database is locked, cannot open it')
    new_datababase= not database_file.is_file()
    if engine is None:
        logger.info(f"Init database: {database_file.resolve()} new: {new_datababase}")
        url= f"sqlite+pysqlite:///{database_file.resolve()}"
        engine= create_engine(url=url)
        from stash_ai.model import BaseModel
        from alembic.config import Config
        from alembic import command
        from alembic.util import AutogenerateDiffsDetected, CommandError
        logger.warning(f"** Engine **")
        with engine.begin() as connection:
            try:
                alembic_cfg_file= database_file.parent.joinpath('alembic.ini')
                logger.info(f"Alembic config file {alembic_cfg_file.resolve()}")
                #alembic_cfg= Config(alembic_cfg_file, attributes={'disable_existing_loggers': True})   
                alembic_cfg= Config(alembic_cfg_file)   
                alembic_cfg.set_main_option('sqlalchemy.url', url)
                #alembic_cfg.attributes['disable_existing_loggers']= True
                alembic_cfg.attributes['connection']= connection
                try:
                    command.check(alembic_cfg)
                except Exception as e:
                    #logger.warning(f"Database check failed {e!s}")
                    # logger.warning("Database upgrade required")
                    # command.upgrade(alembic_cfg, 'head')
                    if new_datababase:
                        logger.warning('Create database schema')
                        BaseModel.metadata.create_all(engine)
                        command.stamp(alembic_cfg, 'head')
                    else:
                        logger.warning('Upgrade database')            
                        command.upgrade(alembic_cfg, 'head')
                logger.warning(f"** CFG-COMMIT {alembic_cfg}")
                connection.commit()
            except Exception as e:
                logger.critical(f"Error database init {e!s}")
                logger.exception(e)
                connection.rollback()
            finally:
                connection.close()

def get_engine() -> Engine:
    if engine is None:
        init_engine()
    return engine

def get_session(*args, **kwargs) -> Session:
    if engine is None:
        init_engine()
    return Session(engine, **kwargs)

def close_db():
    global engine
    if engine is None:
        return
    engine.dispose()
    engine= None
    
def list_backups():
    backup_files= []
    for f in config.encrypted_data.glob('*.sqlite3.aes'):
        backup_name= '.'.join(f.name.split('.')[:-2])
        backup_files.append((backup_name, f"{backup_name} ({datetime.fromtimestamp(f.stat().st_birthtime).isoformat()})"))
    logger.info("Backup files: %s", backup_files)
    return backup_files

def backup_database(backup_name: str) ->bool:
    database_file= config.base_dir.joinpath('stash-ai.sqlite3')    
    if not config.aes_password:
        raise gr.Error("AES password not in configuration. Unable to save an encrypted backup.")
    backup_file= config.encrypted_data.joinpath(f"{backup_name}.sqlite3.aes")
    backup_tarfile= config.encrypted_data.joinpath(f"{backup_name}.tar.gz.aes")
    if backup_file.exists():
        gr.Warning("Backup file already exists")
        return False
    if engine is not None:
        close_db()
    success= False
    try:       
        if not config.encrypted_data.exists():
            config.encrypted_data.mkdir(parents=True)
        pyAesCrypt.encryptFile(database_file, backup_file, config.aes_password) 
        _, tmpfile= tempfile.mkstemp(suffix='.tar.gz')
        tar= tarfile.open(name=tmpfile, mode='w:gz')
        with get_session() as session:
            for row in session.execute(select(ImgFile)).fetchall():
                imgFile: ImgFile= row[0]
                p= imgFile.get_image_path()
                if p.exists():
                    tar.add(name=str(p.resolve()), arcname=str(p.relative_to(config.data_dir)))
        for p in config.data_dir.joinpath('dataset').glob('*'):
            if p.is_file():
                tar.add(name=str(p.resolve()), arcname=str(p.relative_to(config.data_dir)))    
        tar.close()
        pyAesCrypt.encryptFile(tmpfile, backup_tarfile, config.aes_password)
        os.unlink(tmpfile)
        logger.warning(f"Backup completed {backup_file.name} {backup_tarfile.name}")
        success= True
    except Exception as e:
        logger.error("Error encrypting a copy of the database: %s", e)
    return success

def restore_database_backup(backup_name: str) -> str|None:
    database_file= config.base_dir.joinpath('stash-ai.sqlite3')    
    logger.warning("Restore of backup requested")
    backup_file= config.encrypted_data.joinpath(f"{backup_name}.sqlite3.aes")
    backup_tarfile= config.encrypted_data.joinpath(f"{backup_name}.tar.gz.aes")
    
    database_file_bk= database_file.parent.joinpath(f"{database_file.name}.bk")
    if not backup_file.is_file():
        logger.error(f"Backup file {backup_file.resolve()} NOT FOUND")
        return False
    error_message= None
    try:
        close_db()
        if database_file_bk.exists():
            database_file_bk.unlink()
        logger.warning(f"Move current database to {database_file_bk.resolve()}")
        shutil.move(str(database_file.resolve()), str(database_file_bk.resolve()))
        logger.warning("Decrypting backup file")
        pyAesCrypt.decryptFile(backup_file, database_file, config.aes_password)
        if backup_tarfile.exists():
            if not config.data_dir.exists():
                config.data_dir.mkdir(parents=True)
            _, tmpfile= tempfile.mkstemp(suffix='.tar.gz')
            pyAesCrypt.decryptFile(backup_tarfile, tmpfile, config.aes_password)
            tar= tarfile.open(tmpfile, mode='r:gz')
            tar.extractall(path=str(config.data_dir.resolve()))
            tar.close()
            os.unlink(tmpfile)
            
    except Exception as e:
        error_message= f"Error restoring a copy of the database: {e!s}"
        logger.error(error_message)
        if not database_file.is_file() and database_file_bk.is_file():
            logger.warning("Restoring old db from bk file")
            shutil.copy(str(database_file_bk.resolve()), str(database_file.resolve()))
    return error_message
